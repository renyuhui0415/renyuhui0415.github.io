<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Deep Learning Data Operation</title>
    <url>/post/deep_learning_data_operation.html</url>
    <content><![CDATA[<h1 id="什么是深度学习"><a href="#什么是深度学习" class="headerlink" title="什么是深度学习"></a>什么是深度学习</h1><blockquote>
<p>深度学习(DL, Deep Learning)是机器学习(ML, Machine Learning)领域中一个新的研究方向，它被引入机器学习使其更接近于最初的目标——人工智能(AI, Artificial Intelligence)。 深度学习是学习样本数据的内在规律和表示层次，这些学习过程中获得的信息对诸如文字，图像和声音等数据的解释有很大的帮助。它的最终目标是让机器能够像人一样具有分析学习能力，能够识别文字、图像和声音等数据</p>
</blockquote>
<p>下面是李沐老师给出的AI地图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/1.png"
                      alt="AI地图"
                >  </p>
<p>x轴表示的是人工智能领域中的三个主流方法：符号学、概率模型和机器学习。<br>y轴表示的是人工智能的四个核心任务：感知、推理、知识和规划。</p>
<ul>
<li>感知指的是从外部环境中获取并处理信息，比如图像识别、语音识别等任务；</li>
<li>推理指的是通过逻辑推论和演绎等方式，从已有知识中得出新的结论或判断，如证明定理、诊断疾病等任务；</li>
<li>知识指的是人工智能系统对实际世界的认知和理解，包括知识表示、知识库和专家系统等技术</li>
<li>规划指的是根据目标和限制条件，设计出适合实现目标的行动路径或策略，比如路径规划和控制系统设计等任务。</li>
</ul>
<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>暂时先略过，没有GPU服务器，后面有的时候再捣鼓。想搞的可以看一下李沐老师的视频。<br><a class="link"   href="https://www.bilibili.com/video/BV18p4y1h7Dr/" >配置环境 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>我使用的是Google的colab，需要科学上网，登录Google账号， <a class="link"   href="https://colab.research.google.com/" >直达colab <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h1 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h1><h2 id="数据概念"><a href="#数据概念" class="headerlink" title="数据概念"></a>数据概念</h2><p>N维数组（张量）是机器学习和神经网络的主要数据结构。</p>
<ul>
<li>0-d（标量）：0维数组，一个数字，表示一个类别</li>
<li>1-d（向量）：1维数组，如[1.0,2.7,3.4] ，把一些样本抽象成一行数字，表示一个特征向量</li>
<li>2-d（矩阵）：2维数组，有行有列，每一行表示每一个样本，每一列表示不同的特征，表示一个样本的特征矩阵</li>
<li>3-d：比如rgb图片</li>
<li>4-d：n个三维数组放在一起，比如n个图片放在一起。</li>
</ul>
<h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><p>和py里面访问元素一样，下标从0开始。以二维数组（矩阵）为例<br>访问单个元素：[x,y]，第 x + 1行、第 y + 1个元素。<br>访问某一行：[x,:] 第 x + 1行所有元素。<br>访问某一列：[:,y],第y + 1列所有元素<br>访问子区域： [x1:x2,y1:y2]，开区间，表示x1~x2 - 1 行的 y1 ~ y2 - 1列的所有元素。  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/2.png"
                     
                >  </p>
<p>还可以跳着访问，隔几行或者隔几列进行访问。[x1:x2:n,y1:y2:m]表示 x1 ~ x2 -1行隔n行、y1~y2 -1隔 m列的元素。  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/3.png"
                     
                >  </p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>可以使用arange创建一个行向量，默认从0开始的前 n 个整数，也可以指定创建类型为浮点型。张量里面的每一个值都叫张量的元素。  </p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">x = torch.arange(12)</span><br><span class="line"></span><br><span class="line">x</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/4.png"
                     
                > </p>
<p>可以通过张量的 shape 属性来访问张量的形状</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.shape</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/5.png"
                     
                >  </p>
<p>如果只想知道张量中元素的总数，可以检查它的大小</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.numel()</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/6.png"
                     
                >  </p>
<p>如果想改变张量的形状而不改变元素数量和元素值，可以调用reshape函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.reshape(3,4) #3行4列，一般可以省略一个，会自动计算出来</span><br><span class="line">x.reshape(3,-1)</span><br><span class="line">x.reshape(-1,4)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/7.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/8.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/9.png"
                     
                ></p>
<p>有时，我们希望使用全0、全1、其他常量，或者从特定分布中随机采样的数字来初始化矩阵。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.zeros((2,3,4)) #三维</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/10.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.ones((2, 3, 4))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/11.png"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.randn((2, 3, 4))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/12.png"
                     
                ></p>
<p>通过提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值.</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/13.png"
                     
                ></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>对于任意具有相同形状的张量， 常见的标准算术运算符（+、-、*、&#x2F;和**）都可以被升级为按元素运算。 我们可以在同一形状的任意两个张量上调用按元素操作。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([1.0, 2, 4, 8])</span><br><span class="line">y = torch.tensor([2, 2, 2, 2])</span><br><span class="line">x + y, x - y, x * y, x / y, x ** y #**运算符是求幂运算</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/14.png"
                     
                ></p>
<p>也可以进行求幂这样的一元运算符。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">torch.exp(x)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/15.png"
                     
                ></p>
<p>除了按元素计算外，我们还可以执行线性代数运算，包括向量点积和矩阵乘法，后面再说！！！<br>我们也可以把多个张量连结（concatenate）在一起， 把它们端对端地叠起来形成一个更大的张量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4)) #生成0~11的浮点数，3行4列</span><br><span class="line">Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]]) #指定的3行4列元素</span><br><span class="line">torch.cat((X, Y), dim=0), torch.cat((X, Y), dim=1) #(x,y)为input，dim为选择的扩围，必须在0~len(input[0])之间。在这里，0是第一个维度，也就是行，1是第二个维度，也就是列</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/16.png"
                     
                ></p>
<p>还可以通过 &#x3D;&#x3D; 运算符来构建二元张量。当两个对应元素相等时，为true；反之为false<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/17.png"
                     
                ></p>
<p>对张量中的所有元素进行求和，会产生一个单元素张量。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/18.png"
                     
                ></p>
<h2 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h2><p>前面是对形状相同的张量进行计算，下面看看形状不同的张量是否可以进行计算。首先来了解一下广播的概念。<br>广播：对不同形状的张量进行数学运算。<br>看来咱们可以通过广播的方式来对形状不同的张量进行计算，但是需要满足下面的条件。</p>
<ul>
<li>每个张量至少有一个维度。</li>
<li>迭代维度尺寸时，从尾部的维度开始，维度尺寸。 或者相等；​ 或者其中一个张量的维度尺寸为 1 ；​ 或者其中一个张量不存在这个维度。<br>而广播后的结果为：当维度不同时，在维数较少的张量上添加尺寸为1的维度(复制其他维度的)。结果维度尺寸是x、y相应维度尺寸的较大者。<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = torch.arange(3).reshape((3, 1))</span><br><span class="line">b = torch.arange(2).reshape((1, 2))</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">a, b</span><br><span class="line">(tensor([[0],</span><br><span class="line">         [1],</span><br><span class="line">         [2]]), </span><br><span class="line"> tensor([[0, 1]]))</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line"> a + b</span><br><span class="line"> &quot;&quot;&quot;</span><br><span class="line">tensor([[0, 1],</span><br><span class="line">        [1, 2],</span><br><span class="line">        [2, 3]])</span><br><span class="line"> &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></div>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/19.png"
                     
                ></li>
</ul>
<p>进行加法时，a 变成了 [[0,0],[1,1],[2,2]]，b变成了 [[0,1],[0,1],[0,1]]，这样才得出了结果。</p>
<h2 id="节省内存"><a href="#节省内存" class="headerlink" title="节省内存"></a>节省内存</h2><p>当有特别太的矩阵的时候，需要考虑节省内存的事情。但是运行一些操作会导致为新结果分配内存，所以咱们选择执行原地操作。<br>我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如Y[:] &#x3D; <expression></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4))</span><br><span class="line">Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</span><br><span class="line"></span><br><span class="line">#当前值还需要用到的时候，拷贝一下再进行原地操作</span><br><span class="line">Z = torch.zeros_like(Y) #拷贝一下</span><br><span class="line">print(&#x27;id(Z):&#x27;, id(Z)) #py通过id函数可以找到地址</span><br><span class="line">Z[:] = X + Y </span><br><span class="line">print(&#x27;id(Z):&#x27;, id(Z))</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/20.png"
                     
                ></p>
<p>如果某些值后面不会用到，直接对该值进行操作即可</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4))</span><br><span class="line">Y = torch.tensor([[2.0, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])</span><br><span class="line"></span><br><span class="line">before = id(X)</span><br><span class="line">X += Y // x[:] = x + y</span><br><span class="line">id(X) == before #看看是否相等</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/21.png"
                     
                ></p>
<h2 id="转化为其他py对象"><a href="#转化为其他py对象" class="headerlink" title="转化为其他py对象"></a>转化为其他py对象</h2><p>torch张量和numpy数组将共享它们的底层内存，就地操作更改一个张量也会同时更改另一个张量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">X = torch.arange(12, dtype=torch.float32).reshape((3,4))</span><br><span class="line"></span><br><span class="line">A = X.numpy()</span><br><span class="line">B = torch.tensor(A)</span><br><span class="line">type(A), type(B)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/22.png"
                     
                ></p>
<p>要将大小为1的张量转换为Python标量，我们可以调用item函数或Python的内置函数。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line"></span><br><span class="line">a = torch.tensor([3.5])</span><br><span class="line">a, a.item(), float(a), int(a)</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/deep_learning_data_operation/23.png"
                     
                ><br><strong>参考链接：</strong><a class="link"   href="https://zh-v2.d2l.ai/chapter_preliminaries/ndarray.html" >数据操作 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Deep_Learning</category>
      </categories>
      <tags>
        <tag>Deep_Learning</tag>
        <tag>AI</tag>
        <tag>Data_Operation</tag>
        <tag>Preliminary_knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建专属于自己的个人博客</title>
    <url>/post/build_your_blog.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你是否想拥有属于自己的博客，但是又由于不会前端知识、web框架等等 或者 花费时间多 而苦恼，不用担心。接下来跟着这篇文章，你将花费不到20分钟时间拥有自己的博客！！！</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>首先，来讲解一下原理。<br>咱们主要是通过hexo + GitHub Pages 来搭建自己的博客的。<br>下面是 GitHub Pages、hexo的官方说明。</p>
<blockquote>
<p>GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。</p>
</blockquote>
<blockquote>
<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
</blockquote>
<p>刚好hexo又提供了一键部署的功能，可以把网站一键部署到GitHub Pages。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="node-js-安装-配置"><a href="#node-js-安装-配置" class="headerlink" title="node.js 安装 + 配置"></a>node.js 安装 + 配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a class="link"   href="https://pc.qq.com/detail/5/detail_24845.html" >点击即可安装node.js <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>腾讯软件中心下载的比较快，建议在D盘创建一个node.js文件夹。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/node.js_folder.png"
                      alt="node.js文件夹内容"
                ><br>打开电脑终端，输入 node -v、npm -v两个命令查看是否安装成功。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/check.png"
                      alt="检查是否安装成功"
                ></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li><p>在node.js文件夹下创建 node_global、node_cache文件夹,设置 npm 的全局安装路径和缓存路径.</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure></div></li>
<li><p>添加环境变量<br>  win11系统下添加变量步骤: 设置 -&gt; 系统 -&gt; 系统信息 -&gt; 高级系统设置 -&gt; 环境变量<br>  1、添加系统变量  </p>
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/2.png"
                     
                ><br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/3.png"
                     
                >  </p>
<p>  2、添加环境变量  </p>
<p>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/4.png"
                     
                ></p>
</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>接下来咱们测试一下是否配置成功。  </p>
<p><code>npm install express -g</code></p>
<p>如果出现下面报错的话</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express -g</span><br><span class="line">npm ERR! code ETIMEDOUT</span><br><span class="line">npm ERR! syscall connect</span><br><span class="line">npm ERR! errno ETIMEDOUT</span><br><span class="line">npm ERR! network request to https://registry.npmjs.org/express failed, reason: connect ETIMEDOUT 104.16.18.35:443</span><br><span class="line">npm ERR! network This is a problem related to network connectivity.</span><br><span class="line">npm ERR! network In most cases you are behind a proxy or have bad network settings.</span><br><span class="line">npm ERR! network</span><br><span class="line">npm ERR! network If you are behind a proxy, please make sure that the</span><br><span class="line">npm ERR! network &#x27;proxy&#x27; config is set properly.  See: &#x27;npm help config&#x27;</span><br><span class="line"></span><br><span class="line">npm ERR! Log files were not written due to an error writing to the directory: D:\node.js\node_cache\_logs</span><br><span class="line">npm ERR! You can rerun the command with `--loglevel=verbose` to see the logs in your terminal</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>这是npm镜像问题，需要更换npm镜像，改为淘宝的镜像。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></div>

<h3 id="安装其他依赖"><a href="#安装其他依赖" class="headerlink" title="安装其他依赖"></a>安装其他依赖</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm</span><br><span class="line">npm install webpack -g</span><br></pre></td></tr></table></figure></div>
<p>此部分参考链接: <a class="link"   href="https://blog.csdn.net/weixin_52799373/article/details/123840137" >七维大脑的博客 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>注意有些时候需要用管理员去打开cmd，可以选择把cmd发送到桌面，然后右键以管理员权限打开即可。  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/5.png"
                     
                ></p>
<p>这样每次都是管理员身份打开了。  </p>
<h2 id="安装-配置-Git"><a href="#安装-配置-Git" class="headerlink" title="安装+配置 Git"></a>安装+配置 Git</h2><p><a class="link"   href="https://pc.qq.com/detail/13/detail_22693.html" >点击安装Git <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>配置Git全局用户名和邮箱  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;your-email@example.com&quot;</span><br></pre></td></tr></table></figure></div></li>
<li>添加 SSH Key到GitHub账号<br>  首先生成SSH Key  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure></div>
  生成后，会给出地址的，一般是在 C:&#x2F;user&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa.pub<br>  复制后，去github绑定<br>  点击头像 -&gt; settings<br>  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/6.png"
                     
                ><br>  检测是否成功  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div>
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/7.png"
                     
                ></li>
</ul>
<h1 id="创建博客项目"><a href="#创建博客项目" class="headerlink" title="创建博客项目"></a>创建博客项目</h1><h2 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h2><p>首页有一个new，点击即可新建<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/8.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/9.png"
                     
                >  </p>
<h2 id="本地仓库创建"><a href="#本地仓库创建" class="headerlink" title="本地仓库创建"></a>本地仓库创建</h2><p>首先去D盘创建一个文件夹，把读写权限打开，否则后期会有权限问题出现。<br>新建文件夹blog，右键点击属性 -&gt; 安全，把user权限打开<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/10.png"
                     
                ></p>
<h2 id="本地访问博客"><a href="#本地访问博客" class="headerlink" title="本地访问博客"></a>本地访问博客</h2><p>在blog文件夹 右键 -&gt; 显示更多选项 -&gt; git bash<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/11.png"
                     
                ></p>
<p>下一步是安装hexo<br><code>npm install -g hexo-cli</code><br>安装后，可以使用 <code>hexo -v</code>查看是否安装成功，若安装不成功，可以在评论区留言。<br>接下来咱们先看一下hexo的指令，这样才会操作。<a class="link"   href="https://hexo.io/zh-cn/docs/commands.html" >hexo指令 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>首先是新建一个网站 + 在本地运行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init # 默认在当前文件夹新建一个网站</span><br><span class="line">hexo s # 启动访问，默认在http://localhost:4000/</span><br></pre></td></tr></table></figure></div>
<p>注意: hexo init初始化时，文件夹必须为空！！！<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/12.png"
                     
                ></p>
<p>git bash 里面 ctrl + c关闭服务<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/13.png"
                     
                ></p>
<h1 id="部署个人博客"><a href="#部署个人博客" class="headerlink" title="部署个人博客"></a>部署个人博客</h1><p>部署个人博客的话，咱们直接跟着官网走即可 <a class="link"   href="https://hexo.io/zh-cn/docs/one-command-deployment.html" >部署 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/14.png"
                     
                >  </p>
<p>咱们选择的部署插件是git首先安装插件，并更改配置文件<br><code>npm install hexo-deployer-git --save</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/16.png"
                     
                ><br>修改配置文件<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/15.png"
                     
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/17.png"
                     
                ><br>接下来两行命令就可以创建出自己的博客网站了。  </p>
<pre><code>hexo g #生成静态文件
hexo d #部署网站
</code></pre>
<p>此时GitHub仓库已经有刚才生成的静态文件了，而且博客网站已经可以访问了。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/18.png"
                     
                ><br>博客地址<br><code>https://username.github.io</code><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/build_your_blog/19.png"
                     
                ><br>这样就部署好网站了，接下来开始配置自己的网站了。</p>
<h1 id="根据个人喜好修改配置"><a href="#根据个人喜好修改配置" class="headerlink" title="根据个人喜好修改配置"></a>根据个人喜好修改配置</h1><p>hexo提供了好多主题，大家可以根据自己喜欢去选择一个合适主题，跟着主题文档去修改即可。<a class="link"   href="https://hexo.io/themes/" >theme <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>在安装过程中可能会遇到一些报错，大家不用慌，大部分是因为网络原因导致的，耐心尝试即可！<br>注意：有什么不会的查hexo官方文档即可，<a class="link"   href="https://hexo.io/zh-cn/docs/index.html" >hexo官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  </p>
]]></content>
      <categories>
        <category>build your blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github.io</tag>
      </tags>
  </entry>
</search>
